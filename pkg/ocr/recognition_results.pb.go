// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: recognition_results.proto

package ocr

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FontStyle_Style int32

const (
	BOLD          FontStyle_Style = 0
	ITALIC        FontStyle_Style = 1
	UNDERLINE     FontStyle_Style = 2
	STRIKETHROUGH FontStyle_Style = 3
	SUPERSCRIPT   FontStyle_Style = 4
	SUBSCRIPT     FontStyle_Style = 5
	DROPCAP       FontStyle_Style = 6
	SMALLCAPS     FontStyle_Style = 7
)

var FontStyle_Style_name = map[int32]string{
	0: "BOLD",
	1: "ITALIC",
	2: "UNDERLINE",
	3: "STRIKETHROUGH",
	4: "SUPERSCRIPT",
	5: "SUBSCRIPT",
	6: "DROPCAP",
	7: "SMALLCAPS",
}

var FontStyle_Style_value = map[string]int32{
	"BOLD":          0,
	"ITALIC":        1,
	"UNDERLINE":     2,
	"STRIKETHROUGH": 3,
	"SUPERSCRIPT":   4,
	"SUBSCRIPT":     5,
	"DROPCAP":       6,
	"SMALLCAPS":     7,
}

func (FontStyle_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{7, 0}
}

type Document struct {
	// Required
	// Must be set to the value 3.
	Version int32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Required
	// This must be a linearized version of the document represented
	// as characters. It should include the spaces between words
	// and paragraphs as appropriate. Spaces should be represented
	// with the unicode space character. Paragraphs only need a single
	// space between them, they don't need special treatment.
	Characters []*Character `protobuf:"bytes,2,rep,name=characters,proto3" json:"characters,omitempty"`
	// Required
	Pages []*Page `protobuf:"bytes,3,rep,name=pages,proto3" json:"pages,omitempty"`
	// Optional
	Tables []*Table `protobuf:"bytes,4,rep,name=tables,proto3" json:"tables,omitempty"`
	// Optional
	TableCells []*TableCell `protobuf:"bytes,5,rep,name=table_cells,json=tableCells,proto3" json:"table_cells,omitempty"`
	// Optional
	Fonts []*Font `protobuf:"bytes,6,rep,name=fonts,proto3" json:"fonts,omitempty"`
	// Optional
	FontSizes []*FontSize `protobuf:"bytes,7,rep,name=font_sizes,json=fontSizes,proto3" json:"font_sizes,omitempty"`
	// Optional
	FontStyles []*FontStyle `protobuf:"bytes,8,rep,name=font_styles,json=fontStyles,proto3" json:"font_styles,omitempty"`
	// Required
	Md5 []byte `protobuf:"bytes,18,opt,name=md5,proto3" json:"md5,omitempty"`
	// Optional
	// The valid values are : “omnipage” “word2ocr” ““(empty)
	// An empty value is treated equivalently to “omnipage”.
	Source string `protobuf:"bytes,20,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *Document) Reset()      { *m = Document{} }
func (*Document) ProtoMessage() {}
func (*Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{0}
}
func (m *Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Document.Merge(m, src)
}
func (m *Document) XXX_Size() int {
	return m.Size()
}
func (m *Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Document proto.InternalMessageInfo

func (m *Document) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Document) GetCharacters() []*Character {
	if m != nil {
		return m.Characters
	}
	return nil
}

func (m *Document) GetPages() []*Page {
	if m != nil {
		return m.Pages
	}
	return nil
}

func (m *Document) GetTables() []*Table {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *Document) GetTableCells() []*TableCell {
	if m != nil {
		return m.TableCells
	}
	return nil
}

func (m *Document) GetFonts() []*Font {
	if m != nil {
		return m.Fonts
	}
	return nil
}

func (m *Document) GetFontSizes() []*FontSize {
	if m != nil {
		return m.FontSizes
	}
	return nil
}

func (m *Document) GetFontStyles() []*FontStyle {
	if m != nil {
		return m.FontStyles
	}
	return nil
}

func (m *Document) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *Document) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type Character struct {
	// The character as a UTF-16 decimal value. E.g. © is 169.
	Unicode uint32 `protobuf:"varint,1,opt,name=unicode,proto3" json:"unicode,omitempty"`
	// An integer between 0 and 100 where 0 means full confidence and 100 no confidence.
	Error uint32 `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	// The character's bounding box on the page.
	BoundingBox *BoundingBox `protobuf:"bytes,3,opt,name=bounding_box,json=boundingBox,proto3" json:"bounding_box,omitempty"`
}

func (m *Character) Reset()      { *m = Character{} }
func (*Character) ProtoMessage() {}
func (*Character) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{1}
}
func (m *Character) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Character) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Character.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Character) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Character.Merge(m, src)
}
func (m *Character) XXX_Size() int {
	return m.Size()
}
func (m *Character) XXX_DiscardUnknown() {
	xxx_messageInfo_Character.DiscardUnknown(m)
}

var xxx_messageInfo_Character proto.InternalMessageInfo

func (m *Character) GetUnicode() uint32 {
	if m != nil {
		return m.Unicode
	}
	return 0
}

func (m *Character) GetError() uint32 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *Character) GetBoundingBox() *BoundingBox {
	if m != nil {
		return m.BoundingBox
	}
	return nil
}

type Page struct {
	// Required
	// The range of characters the page covers.
	CharacterSpan *Span `protobuf:"bytes,1,opt,name=character_span,json=characterSpan,proto3" json:"character_span,omitempty"`
	// The width of the page in pixels.
	Width uint32 `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	// The height of the page in pixels.
	Height uint32 `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	// The number of horizontal pixels per inch.
	DpiX uint32 `protobuf:"varint,4,opt,name=dpi_x,json=dpiX,proto3" json:"dpi_x,omitempty"`
	// The number of vertical pixels per inch.
	DpiY uint32 `protobuf:"varint,5,opt,name=dpi_y,json=dpiY,proto3" json:"dpi_y,omitempty"`
}

func (m *Page) Reset()      { *m = Page{} }
func (*Page) ProtoMessage() {}
func (*Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{2}
}
func (m *Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page.Merge(m, src)
}
func (m *Page) XXX_Size() int {
	return m.Size()
}
func (m *Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Page proto.InternalMessageInfo

func (m *Page) GetCharacterSpan() *Span {
	if m != nil {
		return m.CharacterSpan
	}
	return nil
}

func (m *Page) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Page) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Page) GetDpiX() uint32 {
	if m != nil {
		return m.DpiX
	}
	return 0
}

func (m *Page) GetDpiY() uint32 {
	if m != nil {
		return m.DpiY
	}
	return 0
}

type Table struct {
	// An arbitrary integer. Each table must have a unique integer identifier.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The page number of the page the table is on, starting from 0.
	PageNumber uint32 `protobuf:"varint,2,opt,name=page_number,json=pageNumber,proto3" json:"page_number,omitempty"`
}

func (m *Table) Reset()      { *m = Table{} }
func (*Table) ProtoMessage() {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{3}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

func (m *Table) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Table) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

type TableCell struct {
	// The id of the table the cell is a part of, matches id in Table.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The bounding box of the cell on the page.
	BoundingBox *BoundingBox `protobuf:"bytes,2,opt,name=bounding_box,json=boundingBox,proto3" json:"bounding_box,omitempty"`
	// The color of the cell.
	BackgroundColor *Color `protobuf:"bytes,3,opt,name=background_color,json=backgroundColor,proto3" json:"background_color,omitempty"`
	// The stroke size of the left border in pixels.
	LeftBorderWidth uint32 `protobuf:"varint,4,opt,name=left_border_width,json=leftBorderWidth,proto3" json:"left_border_width,omitempty"`
	// The stroke size of the right border in pixels.
	RightBorderWidth uint32 `protobuf:"varint,5,opt,name=right_border_width,json=rightBorderWidth,proto3" json:"right_border_width,omitempty"`
	// The stroke size of the top border in pixels.
	TopBorderWidth uint32 `protobuf:"varint,6,opt,name=top_border_width,json=topBorderWidth,proto3" json:"top_border_width,omitempty"`
	// The stroke size of the bottom border in pixels.
	BottomBorderWidth uint32 `protobuf:"varint,7,opt,name=bottom_border_width,json=bottomBorderWidth,proto3" json:"bottom_border_width,omitempty"`
}

func (m *TableCell) Reset()      { *m = TableCell{} }
func (*TableCell) ProtoMessage() {}
func (*TableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{4}
}
func (m *TableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableCell.Merge(m, src)
}
func (m *TableCell) XXX_Size() int {
	return m.Size()
}
func (m *TableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_TableCell.DiscardUnknown(m)
}

var xxx_messageInfo_TableCell proto.InternalMessageInfo

func (m *TableCell) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TableCell) GetBoundingBox() *BoundingBox {
	if m != nil {
		return m.BoundingBox
	}
	return nil
}

func (m *TableCell) GetBackgroundColor() *Color {
	if m != nil {
		return m.BackgroundColor
	}
	return nil
}

func (m *TableCell) GetLeftBorderWidth() uint32 {
	if m != nil {
		return m.LeftBorderWidth
	}
	return 0
}

func (m *TableCell) GetRightBorderWidth() uint32 {
	if m != nil {
		return m.RightBorderWidth
	}
	return 0
}

func (m *TableCell) GetTopBorderWidth() uint32 {
	if m != nil {
		return m.TopBorderWidth
	}
	return 0
}

func (m *TableCell) GetBottomBorderWidth() uint32 {
	if m != nil {
		return m.BottomBorderWidth
	}
	return 0
}

type Font struct {
	// Required
	// The character range that uses this font.
	CharacterSpan *Span `protobuf:"bytes,1,opt,name=character_span,json=characterSpan,proto3" json:"character_span,omitempty"`
	// The name of the font.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// True if the font is a serif.
	Serif bool `protobuf:"varint,3,opt,name=serif,proto3" json:"serif,omitempty"`
	// True if the font is monospaced.
	Monospace bool `protobuf:"varint,4,opt,name=monospace,proto3" json:"monospace,omitempty"`
}

func (m *Font) Reset()      { *m = Font{} }
func (*Font) ProtoMessage() {}
func (*Font) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{5}
}
func (m *Font) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Font) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Font.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Font) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Font.Merge(m, src)
}
func (m *Font) XXX_Size() int {
	return m.Size()
}
func (m *Font) XXX_DiscardUnknown() {
	xxx_messageInfo_Font.DiscardUnknown(m)
}

var xxx_messageInfo_Font proto.InternalMessageInfo

func (m *Font) GetCharacterSpan() *Span {
	if m != nil {
		return m.CharacterSpan
	}
	return nil
}

func (m *Font) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Font) GetSerif() bool {
	if m != nil {
		return m.Serif
	}
	return false
}

func (m *Font) GetMonospace() bool {
	if m != nil {
		return m.Monospace
	}
	return false
}

type FontSize struct {
	// Required
	// The character range this attribute applies to.
	CharacterSpan *Span `protobuf:"bytes,1,opt,name=character_span,json=characterSpan,proto3" json:"character_span,omitempty"`
	// The size of the font in points. A typical point size is 11 or 12.
	Size_ uint32 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *FontSize) Reset()      { *m = FontSize{} }
func (*FontSize) ProtoMessage() {}
func (*FontSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{6}
}
func (m *FontSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FontSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FontSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FontSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FontSize.Merge(m, src)
}
func (m *FontSize) XXX_Size() int {
	return m.Size()
}
func (m *FontSize) XXX_DiscardUnknown() {
	xxx_messageInfo_FontSize.DiscardUnknown(m)
}

var xxx_messageInfo_FontSize proto.InternalMessageInfo

func (m *FontSize) GetCharacterSpan() *Span {
	if m != nil {
		return m.CharacterSpan
	}
	return nil
}

func (m *FontSize) GetSize_() uint32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type FontStyle struct {
	// Required
	// The character span this attribute applies to. TODO: consistent naming!
	CharacterSpan *Span `protobuf:"bytes,1,opt,name=character_span,json=characterSpan,proto3" json:"character_span,omitempty"`
	// The style of the text in this span.
	Style FontStyle_Style `protobuf:"varint,8,opt,name=style,proto3,enum=ocr.FontStyle_Style" json:"style,omitempty"`
}

func (m *FontStyle) Reset()      { *m = FontStyle{} }
func (*FontStyle) ProtoMessage() {}
func (*FontStyle) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{7}
}
func (m *FontStyle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FontStyle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FontStyle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FontStyle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FontStyle.Merge(m, src)
}
func (m *FontStyle) XXX_Size() int {
	return m.Size()
}
func (m *FontStyle) XXX_DiscardUnknown() {
	xxx_messageInfo_FontStyle.DiscardUnknown(m)
}

var xxx_messageInfo_FontStyle proto.InternalMessageInfo

func (m *FontStyle) GetCharacterSpan() *Span {
	if m != nil {
		return m.CharacterSpan
	}
	return nil
}

func (m *FontStyle) GetStyle() FontStyle_Style {
	if m != nil {
		return m.Style
	}
	return BOLD
}

type Color struct {
	R uint32 `protobuf:"varint,1,opt,name=r,proto3" json:"r,omitempty"`
	G uint32 `protobuf:"varint,2,opt,name=g,proto3" json:"g,omitempty"`
	B uint32 `protobuf:"varint,3,opt,name=b,proto3" json:"b,omitempty"`
}

func (m *Color) Reset()      { *m = Color{} }
func (*Color) ProtoMessage() {}
func (*Color) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{8}
}
func (m *Color) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Color) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Color.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Color) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Color.Merge(m, src)
}
func (m *Color) XXX_Size() int {
	return m.Size()
}
func (m *Color) XXX_DiscardUnknown() {
	xxx_messageInfo_Color.DiscardUnknown(m)
}

var xxx_messageInfo_Color proto.InternalMessageInfo

func (m *Color) GetR() uint32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *Color) GetG() uint32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *Color) GetB() uint32 {
	if m != nil {
		return m.B
	}
	return 0
}

type BoundingBox struct {
	// The top left coordinate of the bounding box. The top left of the
	// page is considered to be 0,0.
	X1 uint32 `protobuf:"varint,1,opt,name=x1,proto3" json:"x1,omitempty"`
	Y1 uint32 `protobuf:"varint,2,opt,name=y1,proto3" json:"y1,omitempty"`
	// The bottom right coordinate of the bounding box.
	X2 uint32 `protobuf:"varint,3,opt,name=x2,proto3" json:"x2,omitempty"`
	Y2 uint32 `protobuf:"varint,4,opt,name=y2,proto3" json:"y2,omitempty"`
}

func (m *BoundingBox) Reset()      { *m = BoundingBox{} }
func (*BoundingBox) ProtoMessage() {}
func (*BoundingBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{9}
}
func (m *BoundingBox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoundingBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoundingBox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoundingBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingBox.Merge(m, src)
}
func (m *BoundingBox) XXX_Size() int {
	return m.Size()
}
func (m *BoundingBox) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingBox.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingBox proto.InternalMessageInfo

func (m *BoundingBox) GetX1() uint32 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *BoundingBox) GetY1() uint32 {
	if m != nil {
		return m.Y1
	}
	return 0
}

func (m *BoundingBox) GetX2() uint32 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *BoundingBox) GetY2() uint32 {
	if m != nil {
		return m.Y2
	}
	return 0
}

type Span struct {
	Start uint32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   uint32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Span) Reset()      { *m = Span{} }
func (*Span) ProtoMessage() {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_858eea15045a59a5, []int{10}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Span) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func init() {
	proto.RegisterEnum("ocr.FontStyle_Style", FontStyle_Style_name, FontStyle_Style_value)
	proto.RegisterType((*Document)(nil), "ocr.Document")
	proto.RegisterType((*Character)(nil), "ocr.Character")
	proto.RegisterType((*Page)(nil), "ocr.Page")
	proto.RegisterType((*Table)(nil), "ocr.Table")
	proto.RegisterType((*TableCell)(nil), "ocr.TableCell")
	proto.RegisterType((*Font)(nil), "ocr.Font")
	proto.RegisterType((*FontSize)(nil), "ocr.FontSize")
	proto.RegisterType((*FontStyle)(nil), "ocr.FontStyle")
	proto.RegisterType((*Color)(nil), "ocr.Color")
	proto.RegisterType((*BoundingBox)(nil), "ocr.BoundingBox")
	proto.RegisterType((*Span)(nil), "ocr.Span")
}

func init() { proto.RegisterFile("recognition_results.proto", fileDescriptor_858eea15045a59a5) }

var fileDescriptor_858eea15045a59a5 = []byte{
	// 913 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xd6, 0x52, 0xa4, 0x24, 0x8e, 0x2c, 0x9b, 0xde, 0x18, 0x05, 0x0b, 0x14, 0x8c, 0xc0, 0x93,
	0x10, 0x04, 0x6a, 0xad, 0x34, 0x40, 0xaf, 0x96, 0xec, 0x36, 0x4e, 0x1d, 0x5b, 0x58, 0xc9, 0x68,
	0x7b, 0x22, 0xf8, 0xb3, 0x92, 0x88, 0x4a, 0x5c, 0x62, 0xb9, 0x6a, 0xa5, 0xf4, 0x92, 0x47, 0x08,
	0xfa, 0x14, 0x7d, 0x87, 0xbe, 0x40, 0x8f, 0x3e, 0xe6, 0x58, 0xcb, 0x40, 0xd1, 0x63, 0x1e, 0xa1,
	0xd8, 0x25, 0x29, 0xcb, 0xed, 0xa5, 0xf0, 0x6d, 0xbe, 0x6f, 0x3e, 0xee, 0xec, 0x7e, 0x3b, 0xb3,
	0x84, 0x4f, 0x39, 0x0d, 0xd9, 0x34, 0x89, 0x45, 0xcc, 0x12, 0x8f, 0xd3, 0x6c, 0x39, 0x17, 0x59,
	0x37, 0xe5, 0x4c, 0x30, 0x5c, 0x65, 0x21, 0x77, 0x7f, 0xad, 0x42, 0xe3, 0x94, 0x85, 0xcb, 0x05,
	0x4d, 0x04, 0xb6, 0xa1, 0xfe, 0x13, 0xe5, 0x59, 0xcc, 0x12, 0x1b, 0xb5, 0x51, 0xc7, 0x20, 0x25,
	0xc4, 0x5d, 0x80, 0x70, 0xe6, 0x73, 0x3f, 0x14, 0x94, 0x67, 0xb6, 0xd6, 0xae, 0x76, 0x9a, 0xbd,
	0xfd, 0x2e, 0x0b, 0x79, 0x77, 0x50, 0xd2, 0x64, 0x47, 0x81, 0x9f, 0x82, 0x91, 0xfa, 0x53, 0x9a,
	0xd9, 0x55, 0x25, 0x35, 0x95, 0x74, 0xe8, 0x4f, 0x29, 0xc9, 0x79, 0xec, 0x42, 0x4d, 0xf8, 0xc1,
	0x9c, 0x66, 0xb6, 0xae, 0x14, 0xa0, 0x14, 0x63, 0x49, 0x91, 0x22, 0x83, 0x3f, 0x87, 0xa6, 0x8a,
	0xbc, 0x90, 0xce, 0xe7, 0x99, 0x6d, 0xec, 0x54, 0x55, 0xc2, 0x01, 0x9d, 0xcf, 0x09, 0x88, 0x32,
	0x54, 0x55, 0x27, 0x2c, 0x11, 0x99, 0x5d, 0xdb, 0xa9, 0xfa, 0x35, 0x4b, 0x04, 0xc9, 0x79, 0xfc,
	0x1c, 0x40, 0x06, 0x5e, 0x16, 0xbf, 0xa5, 0x99, 0x5d, 0x57, 0xaa, 0xd6, 0x56, 0x35, 0x8a, 0xdf,
	0x52, 0x62, 0x4e, 0x8a, 0x48, 0xd5, 0xcf, 0xd5, 0x62, 0x2d, 0x37, 0xda, 0xd8, 0xa9, 0xaf, 0xe4,
	0x92, 0x26, 0x6a, 0x41, 0x15, 0x66, 0xd8, 0x82, 0xea, 0x22, 0x7a, 0x69, 0xe3, 0x36, 0xea, 0xec,
	0x11, 0x19, 0xe2, 0x4f, 0xa0, 0x96, 0xb1, 0x25, 0x0f, 0xa9, 0x7d, 0xd4, 0x46, 0x1d, 0x93, 0x14,
	0xe8, 0xb5, 0xde, 0x30, 0x2d, 0x78, 0xad, 0x37, 0xc0, 0x6a, 0x92, 0xfa, 0x8c, 0xfa, 0x11, 0xe5,
	0x19, 0xa9, 0x4f, 0x18, 0x93, 0xee, 0xb9, 0x29, 0x98, 0x5b, 0x5b, 0xe5, 0xa5, 0x2c, 0x93, 0x38,
	0x64, 0x11, 0x55, 0x97, 0xd2, 0x22, 0x25, 0xc4, 0x47, 0x60, 0x50, 0xce, 0x19, 0xb7, 0x35, 0xc5,
	0xe7, 0x00, 0xbf, 0x80, 0xbd, 0x80, 0x2d, 0x93, 0x28, 0x4e, 0xa6, 0x5e, 0xc0, 0x56, 0x76, 0xb5,
	0x8d, 0x3a, 0xcd, 0x9e, 0xa5, 0xb6, 0xdd, 0x2f, 0x12, 0x7d, 0xb6, 0x22, 0xcd, 0xe0, 0x1e, 0xb8,
	0xef, 0x11, 0xe8, 0xf2, 0x7a, 0xf0, 0x17, 0xb0, 0xbf, 0xbd, 0x46, 0x2f, 0x4b, 0xfd, 0xbc, 0x13,
	0x4a, 0x2f, 0x47, 0xa9, 0x9f, 0x90, 0xd6, 0x56, 0x20, 0xa1, 0xdc, 0xc5, 0xcf, 0x71, 0x24, 0x66,
	0xe5, 0x2e, 0x14, 0x90, 0x07, 0x9f, 0xd1, 0x78, 0x3a, 0x13, 0xaa, 0x7e, 0x8b, 0x14, 0x08, 0x3f,
	0x01, 0x23, 0x4a, 0x63, 0x6f, 0x65, 0xeb, 0x8a, 0xd6, 0xa3, 0x34, 0xfe, 0xbe, 0x24, 0xd7, 0xb6,
	0xb1, 0x25, 0x7f, 0x70, 0xbf, 0x02, 0x43, 0xdd, 0x32, 0xde, 0x07, 0x2d, 0x8e, 0x8a, 0xb3, 0x6b,
	0x71, 0x84, 0x9f, 0x42, 0x53, 0xf6, 0x90, 0x97, 0x2c, 0x17, 0x01, 0x2d, 0x0f, 0x0f, 0x92, 0xba,
	0x54, 0x8c, 0xfb, 0xbb, 0x06, 0xe6, 0xb6, 0x41, 0xfe, 0xf3, 0xf9, 0xbf, 0xfd, 0xd1, 0xfe, 0x87,
	0x3f, 0xf8, 0x25, 0x58, 0x81, 0x1f, 0xfe, 0x38, 0xe5, 0x92, 0xf3, 0x42, 0x36, 0x67, 0xbc, 0x30,
	0x36, 0x6f, 0xdc, 0x81, 0x64, 0xc8, 0xc1, 0xbd, 0x46, 0x11, 0xf8, 0x19, 0x1c, 0xce, 0xe9, 0x44,
	0x78, 0x01, 0xe3, 0x11, 0xe5, 0x5e, 0xee, 0x53, 0x7e, 0xf2, 0x03, 0x99, 0xe8, 0x2b, 0xfe, 0x3b,
	0xe5, 0xd8, 0x73, 0xc0, 0x5c, 0x5a, 0xf4, 0x50, 0x9c, 0x3b, 0x62, 0xa9, 0xcc, 0xae, 0xba, 0x03,
	0x96, 0x60, 0xe9, 0x43, 0x6d, 0x4d, 0x69, 0xf7, 0x05, 0x4b, 0x77, 0x95, 0x5d, 0x78, 0x12, 0x30,
	0x21, 0xd8, 0xe2, 0xa1, 0xb8, 0xae, 0xc4, 0x87, 0x79, 0x6a, 0x47, 0xef, 0xbe, 0x43, 0xa0, 0xcb,
	0xf6, 0x7e, 0x44, 0x2b, 0x60, 0xd0, 0x13, 0x7f, 0x41, 0x95, 0xa5, 0x26, 0x51, 0xb1, 0x6c, 0x8f,
	0x8c, 0xf2, 0x78, 0xa2, 0xec, 0x6a, 0x90, 0x1c, 0xe0, 0xcf, 0xc0, 0x5c, 0xb0, 0x84, 0x65, 0xa9,
	0x1f, 0x52, 0x65, 0x48, 0x83, 0xdc, 0x13, 0xee, 0x10, 0x1a, 0xe5, 0x3c, 0x3e, 0x6e, 0x17, 0x72,
	0xbe, 0x8b, 0xc6, 0x50, 0xb1, 0xfb, 0x17, 0x02, 0x73, 0x3b, 0xb3, 0x8f, 0x58, 0xf3, 0x19, 0x18,
	0xea, 0x15, 0xb0, 0x1b, 0x6d, 0xd4, 0xd9, 0xef, 0x1d, 0x3d, 0x7c, 0x04, 0xba, 0xf9, 0x53, 0x90,
	0x4b, 0xdc, 0x5f, 0xc0, 0xc8, 0xcb, 0x34, 0x40, 0xef, 0x5f, 0x5d, 0x9c, 0x5a, 0x15, 0x0c, 0x50,
	0x3b, 0x1f, 0x9f, 0x5c, 0x9c, 0x0f, 0x2c, 0x84, 0x5b, 0x60, 0x5e, 0x5f, 0x9e, 0x9e, 0x91, 0x8b,
	0xf3, 0xcb, 0x33, 0x4b, 0xc3, 0x87, 0xd0, 0x1a, 0x8d, 0xc9, 0xf9, 0xb7, 0x67, 0xe3, 0x57, 0xe4,
	0xea, 0xfa, 0x9b, 0x57, 0x56, 0x15, 0x1f, 0x40, 0x73, 0x74, 0x3d, 0x3c, 0x23, 0xa3, 0x01, 0x39,
	0x1f, 0x8e, 0x2d, 0x5d, 0x7e, 0x32, 0xba, 0xee, 0x17, 0xd0, 0xc0, 0x4d, 0xa8, 0x9f, 0x92, 0xab,
	0xe1, 0xe0, 0x64, 0x68, 0xd5, 0x54, 0xee, 0xcd, 0xc9, 0xc5, 0xc5, 0xe0, 0x64, 0x38, 0xb2, 0xea,
	0xee, 0x31, 0x18, 0x79, 0xeb, 0xed, 0x01, 0xe2, 0x45, 0xd7, 0x23, 0x85, 0xa6, 0x85, 0x21, 0x68,
	0x2a, 0x51, 0x50, 0xcc, 0x25, 0x0a, 0xdc, 0x37, 0xd0, 0xdc, 0xe9, 0x7b, 0x39, 0x2f, 0xab, 0xe3,
	0x72, 0x5e, 0x56, 0xc7, 0x12, 0xaf, 0x8f, 0x8b, 0x6f, 0xb5, 0xb5, 0xc2, 0xab, 0x5e, 0xf1, 0xb5,
	0xb6, 0xea, 0xa9, 0x7c, 0xaf, 0x68, 0x6a, 0x6d, 0xdd, 0x73, 0xbb, 0xa0, 0x97, 0xef, 0x42, 0x26,
	0x7c, 0x2e, 0x8a, 0xa5, 0x72, 0x20, 0x9f, 0x48, 0x9a, 0x44, 0xc5, 0x72, 0x32, 0xec, 0x7f, 0x79,
	0x73, 0xeb, 0x54, 0x3e, 0xdc, 0x3a, 0x95, 0x8f, 0xb7, 0x0e, 0x7a, 0xb7, 0x71, 0xd0, 0x6f, 0x1b,
	0x07, 0xfd, 0xb1, 0x71, 0xd0, 0xcd, 0xc6, 0x41, 0x7f, 0x6e, 0x1c, 0xf4, 0xf7, 0xc6, 0xa9, 0x7c,
	0xdc, 0x38, 0xe8, 0xfd, 0x9d, 0x53, 0xb9, 0xb9, 0x73, 0x2a, 0x1f, 0xee, 0x9c, 0x4a, 0x50, 0x53,
	0xff, 0xb0, 0x17, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x29, 0x7d, 0x33, 0xe0, 0x06, 0x00,
	0x00,
}

func (x FontStyle_Style) String() string {
	s, ok := FontStyle_Style_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Document) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Document)
	if !ok {
		that2, ok := that.(Document)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if len(this.Characters) != len(that1.Characters) {
		return false
	}
	for i := range this.Characters {
		if !this.Characters[i].Equal(that1.Characters[i]) {
			return false
		}
	}
	if len(this.Pages) != len(that1.Pages) {
		return false
	}
	for i := range this.Pages {
		if !this.Pages[i].Equal(that1.Pages[i]) {
			return false
		}
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if !this.Tables[i].Equal(that1.Tables[i]) {
			return false
		}
	}
	if len(this.TableCells) != len(that1.TableCells) {
		return false
	}
	for i := range this.TableCells {
		if !this.TableCells[i].Equal(that1.TableCells[i]) {
			return false
		}
	}
	if len(this.Fonts) != len(that1.Fonts) {
		return false
	}
	for i := range this.Fonts {
		if !this.Fonts[i].Equal(that1.Fonts[i]) {
			return false
		}
	}
	if len(this.FontSizes) != len(that1.FontSizes) {
		return false
	}
	for i := range this.FontSizes {
		if !this.FontSizes[i].Equal(that1.FontSizes[i]) {
			return false
		}
	}
	if len(this.FontStyles) != len(that1.FontStyles) {
		return false
	}
	for i := range this.FontStyles {
		if !this.FontStyles[i].Equal(that1.FontStyles[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Md5, that1.Md5) {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	return true
}
func (this *Character) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Character)
	if !ok {
		that2, ok := that.(Character)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Unicode != that1.Unicode {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !this.BoundingBox.Equal(that1.BoundingBox) {
		return false
	}
	return true
}
func (this *Page) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Page)
	if !ok {
		that2, ok := that.(Page)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CharacterSpan.Equal(that1.CharacterSpan) {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.DpiX != that1.DpiX {
		return false
	}
	if this.DpiY != that1.DpiY {
		return false
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PageNumber != that1.PageNumber {
		return false
	}
	return true
}
func (this *TableCell) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableCell)
	if !ok {
		that2, ok := that.(TableCell)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.BoundingBox.Equal(that1.BoundingBox) {
		return false
	}
	if !this.BackgroundColor.Equal(that1.BackgroundColor) {
		return false
	}
	if this.LeftBorderWidth != that1.LeftBorderWidth {
		return false
	}
	if this.RightBorderWidth != that1.RightBorderWidth {
		return false
	}
	if this.TopBorderWidth != that1.TopBorderWidth {
		return false
	}
	if this.BottomBorderWidth != that1.BottomBorderWidth {
		return false
	}
	return true
}
func (this *Font) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Font)
	if !ok {
		that2, ok := that.(Font)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CharacterSpan.Equal(that1.CharacterSpan) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Serif != that1.Serif {
		return false
	}
	if this.Monospace != that1.Monospace {
		return false
	}
	return true
}
func (this *FontSize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FontSize)
	if !ok {
		that2, ok := that.(FontSize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CharacterSpan.Equal(that1.CharacterSpan) {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	return true
}
func (this *FontStyle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FontStyle)
	if !ok {
		that2, ok := that.(FontStyle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CharacterSpan.Equal(that1.CharacterSpan) {
		return false
	}
	if this.Style != that1.Style {
		return false
	}
	return true
}
func (this *Color) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Color)
	if !ok {
		that2, ok := that.(Color)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.R != that1.R {
		return false
	}
	if this.G != that1.G {
		return false
	}
	if this.B != that1.B {
		return false
	}
	return true
}
func (this *BoundingBox) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoundingBox)
	if !ok {
		that2, ok := that.(BoundingBox)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.Y1 != that1.Y1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.Y2 != that1.Y2 {
		return false
	}
	return true
}
func (this *Span) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Span)
	if !ok {
		that2, ok := that.(Span)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *Document) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&ocr.Document{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.Characters != nil {
		s = append(s, "Characters: "+fmt.Sprintf("%#v", this.Characters)+",\n")
	}
	if this.Pages != nil {
		s = append(s, "Pages: "+fmt.Sprintf("%#v", this.Pages)+",\n")
	}
	if this.Tables != nil {
		s = append(s, "Tables: "+fmt.Sprintf("%#v", this.Tables)+",\n")
	}
	if this.TableCells != nil {
		s = append(s, "TableCells: "+fmt.Sprintf("%#v", this.TableCells)+",\n")
	}
	if this.Fonts != nil {
		s = append(s, "Fonts: "+fmt.Sprintf("%#v", this.Fonts)+",\n")
	}
	if this.FontSizes != nil {
		s = append(s, "FontSizes: "+fmt.Sprintf("%#v", this.FontSizes)+",\n")
	}
	if this.FontStyles != nil {
		s = append(s, "FontStyles: "+fmt.Sprintf("%#v", this.FontStyles)+",\n")
	}
	s = append(s, "Md5: "+fmt.Sprintf("%#v", this.Md5)+",\n")
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Character) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ocr.Character{")
	s = append(s, "Unicode: "+fmt.Sprintf("%#v", this.Unicode)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	if this.BoundingBox != nil {
		s = append(s, "BoundingBox: "+fmt.Sprintf("%#v", this.BoundingBox)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Page) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&ocr.Page{")
	if this.CharacterSpan != nil {
		s = append(s, "CharacterSpan: "+fmt.Sprintf("%#v", this.CharacterSpan)+",\n")
	}
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "DpiX: "+fmt.Sprintf("%#v", this.DpiX)+",\n")
	s = append(s, "DpiY: "+fmt.Sprintf("%#v", this.DpiY)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Table) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ocr.Table{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "PageNumber: "+fmt.Sprintf("%#v", this.PageNumber)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TableCell) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&ocr.TableCell{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.BoundingBox != nil {
		s = append(s, "BoundingBox: "+fmt.Sprintf("%#v", this.BoundingBox)+",\n")
	}
	if this.BackgroundColor != nil {
		s = append(s, "BackgroundColor: "+fmt.Sprintf("%#v", this.BackgroundColor)+",\n")
	}
	s = append(s, "LeftBorderWidth: "+fmt.Sprintf("%#v", this.LeftBorderWidth)+",\n")
	s = append(s, "RightBorderWidth: "+fmt.Sprintf("%#v", this.RightBorderWidth)+",\n")
	s = append(s, "TopBorderWidth: "+fmt.Sprintf("%#v", this.TopBorderWidth)+",\n")
	s = append(s, "BottomBorderWidth: "+fmt.Sprintf("%#v", this.BottomBorderWidth)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Font) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ocr.Font{")
	if this.CharacterSpan != nil {
		s = append(s, "CharacterSpan: "+fmt.Sprintf("%#v", this.CharacterSpan)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Serif: "+fmt.Sprintf("%#v", this.Serif)+",\n")
	s = append(s, "Monospace: "+fmt.Sprintf("%#v", this.Monospace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FontSize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ocr.FontSize{")
	if this.CharacterSpan != nil {
		s = append(s, "CharacterSpan: "+fmt.Sprintf("%#v", this.CharacterSpan)+",\n")
	}
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FontStyle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ocr.FontStyle{")
	if this.CharacterSpan != nil {
		s = append(s, "CharacterSpan: "+fmt.Sprintf("%#v", this.CharacterSpan)+",\n")
	}
	s = append(s, "Style: "+fmt.Sprintf("%#v", this.Style)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Color) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&ocr.Color{")
	s = append(s, "R: "+fmt.Sprintf("%#v", this.R)+",\n")
	s = append(s, "G: "+fmt.Sprintf("%#v", this.G)+",\n")
	s = append(s, "B: "+fmt.Sprintf("%#v", this.B)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BoundingBox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&ocr.BoundingBox{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "Y1: "+fmt.Sprintf("%#v", this.Y1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "Y2: "+fmt.Sprintf("%#v", this.Y2)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Span) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&ocr.Span{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRecognitionResults(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintRecognitionResults(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintRecognitionResults(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.FontStyles) > 0 {
		for iNdEx := len(m.FontStyles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FontStyles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FontSizes) > 0 {
		for iNdEx := len(m.FontSizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FontSizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Fonts) > 0 {
		for iNdEx := len(m.Fonts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fonts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TableCells) > 0 {
		for iNdEx := len(m.TableCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Pages) > 0 {
		for iNdEx := len(m.Pages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Characters) > 0 {
		for iNdEx := len(m.Characters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Characters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Version != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Character) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Character) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Character) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BoundingBox != nil {
		{
			size, err := m.BoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Error != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Error))
		i--
		dAtA[i] = 0x10
	}
	if m.Unicode != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Unicode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DpiY != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.DpiY))
		i--
		dAtA[i] = 0x28
	}
	if m.DpiX != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.DpiX))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if m.Width != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x10
	}
	if m.CharacterSpan != nil {
		{
			size, err := m.CharacterSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PageNumber != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.PageNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BottomBorderWidth != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.BottomBorderWidth))
		i--
		dAtA[i] = 0x38
	}
	if m.TopBorderWidth != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.TopBorderWidth))
		i--
		dAtA[i] = 0x30
	}
	if m.RightBorderWidth != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.RightBorderWidth))
		i--
		dAtA[i] = 0x28
	}
	if m.LeftBorderWidth != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.LeftBorderWidth))
		i--
		dAtA[i] = 0x20
	}
	if m.BackgroundColor != nil {
		{
			size, err := m.BackgroundColor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BoundingBox != nil {
		{
			size, err := m.BoundingBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Font) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Font) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Font) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Monospace {
		i--
		if m.Monospace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Serif {
		i--
		if m.Serif {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRecognitionResults(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CharacterSpan != nil {
		{
			size, err := m.CharacterSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FontSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FontSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FontSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.CharacterSpan != nil {
		{
			size, err := m.CharacterSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FontStyle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FontStyle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FontStyle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x40
	}
	if m.CharacterSpan != nil {
		{
			size, err := m.CharacterSpan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRecognitionResults(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Color) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Color) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Color) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.B != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x18
	}
	if m.G != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.G))
		i--
		dAtA[i] = 0x10
	}
	if m.R != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.R))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoundingBox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoundingBox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoundingBox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y2 != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Y2))
		i--
		dAtA[i] = 0x20
	}
	if m.X2 != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.X2))
		i--
		dAtA[i] = 0x18
	}
	if m.Y1 != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Y1))
		i--
		dAtA[i] = 0x10
	}
	if m.X1 != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.X1))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintRecognitionResults(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRecognitionResults(dAtA []byte, offset int, v uint64) int {
	offset -= sovRecognitionResults(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Version))
	}
	if len(m.Characters) > 0 {
		for _, e := range m.Characters {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.TableCells) > 0 {
		for _, e := range m.TableCells {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.Fonts) > 0 {
		for _, e := range m.Fonts {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.FontSizes) > 0 {
		for _, e := range m.FontSizes {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	if len(m.FontStyles) > 0 {
		for _, e := range m.FontStyles {
			l = e.Size()
			n += 1 + l + sovRecognitionResults(uint64(l))
		}
	}
	l = len(m.Md5)
	if l > 0 {
		n += 2 + l + sovRecognitionResults(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 2 + l + sovRecognitionResults(uint64(l))
	}
	return n
}

func (m *Character) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unicode != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Unicode))
	}
	if m.Error != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Error))
	}
	if m.BoundingBox != nil {
		l = m.BoundingBox.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	return n
}

func (m *Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterSpan != nil {
		l = m.CharacterSpan.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Height))
	}
	if m.DpiX != 0 {
		n += 1 + sovRecognitionResults(uint64(m.DpiX))
	}
	if m.DpiY != 0 {
		n += 1 + sovRecognitionResults(uint64(m.DpiY))
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Id))
	}
	if m.PageNumber != 0 {
		n += 1 + sovRecognitionResults(uint64(m.PageNumber))
	}
	return n
}

func (m *TableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Id))
	}
	if m.BoundingBox != nil {
		l = m.BoundingBox.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.BackgroundColor != nil {
		l = m.BackgroundColor.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.LeftBorderWidth != 0 {
		n += 1 + sovRecognitionResults(uint64(m.LeftBorderWidth))
	}
	if m.RightBorderWidth != 0 {
		n += 1 + sovRecognitionResults(uint64(m.RightBorderWidth))
	}
	if m.TopBorderWidth != 0 {
		n += 1 + sovRecognitionResults(uint64(m.TopBorderWidth))
	}
	if m.BottomBorderWidth != 0 {
		n += 1 + sovRecognitionResults(uint64(m.BottomBorderWidth))
	}
	return n
}

func (m *Font) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterSpan != nil {
		l = m.CharacterSpan.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.Serif {
		n += 2
	}
	if m.Monospace {
		n += 2
	}
	return n
}

func (m *FontSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterSpan != nil {
		l = m.CharacterSpan.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Size_))
	}
	return n
}

func (m *FontStyle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterSpan != nil {
		l = m.CharacterSpan.Size()
		n += 1 + l + sovRecognitionResults(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Style))
	}
	return n
}

func (m *Color) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R != 0 {
		n += 1 + sovRecognitionResults(uint64(m.R))
	}
	if m.G != 0 {
		n += 1 + sovRecognitionResults(uint64(m.G))
	}
	if m.B != 0 {
		n += 1 + sovRecognitionResults(uint64(m.B))
	}
	return n
}

func (m *BoundingBox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 1 + sovRecognitionResults(uint64(m.X1))
	}
	if m.Y1 != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Y1))
	}
	if m.X2 != 0 {
		n += 1 + sovRecognitionResults(uint64(m.X2))
	}
	if m.Y2 != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Y2))
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovRecognitionResults(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovRecognitionResults(uint64(m.End))
	}
	return n
}

func sovRecognitionResults(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRecognitionResults(x uint64) (n int) {
	return sovRecognitionResults(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Document) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCharacters := "[]*Character{"
	for _, f := range this.Characters {
		repeatedStringForCharacters += strings.Replace(f.String(), "Character", "Character", 1) + ","
	}
	repeatedStringForCharacters += "}"
	repeatedStringForPages := "[]*Page{"
	for _, f := range this.Pages {
		repeatedStringForPages += strings.Replace(f.String(), "Page", "Page", 1) + ","
	}
	repeatedStringForPages += "}"
	repeatedStringForTables := "[]*Table{"
	for _, f := range this.Tables {
		repeatedStringForTables += strings.Replace(f.String(), "Table", "Table", 1) + ","
	}
	repeatedStringForTables += "}"
	repeatedStringForTableCells := "[]*TableCell{"
	for _, f := range this.TableCells {
		repeatedStringForTableCells += strings.Replace(f.String(), "TableCell", "TableCell", 1) + ","
	}
	repeatedStringForTableCells += "}"
	repeatedStringForFonts := "[]*Font{"
	for _, f := range this.Fonts {
		repeatedStringForFonts += strings.Replace(f.String(), "Font", "Font", 1) + ","
	}
	repeatedStringForFonts += "}"
	repeatedStringForFontSizes := "[]*FontSize{"
	for _, f := range this.FontSizes {
		repeatedStringForFontSizes += strings.Replace(f.String(), "FontSize", "FontSize", 1) + ","
	}
	repeatedStringForFontSizes += "}"
	repeatedStringForFontStyles := "[]*FontStyle{"
	for _, f := range this.FontStyles {
		repeatedStringForFontStyles += strings.Replace(f.String(), "FontStyle", "FontStyle", 1) + ","
	}
	repeatedStringForFontStyles += "}"
	s := strings.Join([]string{`&Document{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Characters:` + repeatedStringForCharacters + `,`,
		`Pages:` + repeatedStringForPages + `,`,
		`Tables:` + repeatedStringForTables + `,`,
		`TableCells:` + repeatedStringForTableCells + `,`,
		`Fonts:` + repeatedStringForFonts + `,`,
		`FontSizes:` + repeatedStringForFontSizes + `,`,
		`FontStyles:` + repeatedStringForFontStyles + `,`,
		`Md5:` + fmt.Sprintf("%v", this.Md5) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Character) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Character{`,
		`Unicode:` + fmt.Sprintf("%v", this.Unicode) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`BoundingBox:` + strings.Replace(this.BoundingBox.String(), "BoundingBox", "BoundingBox", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Page) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Page{`,
		`CharacterSpan:` + strings.Replace(this.CharacterSpan.String(), "Span", "Span", 1) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`DpiX:` + fmt.Sprintf("%v", this.DpiX) + `,`,
		`DpiY:` + fmt.Sprintf("%v", this.DpiY) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Table) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Table{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`PageNumber:` + fmt.Sprintf("%v", this.PageNumber) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TableCell) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TableCell{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`BoundingBox:` + strings.Replace(this.BoundingBox.String(), "BoundingBox", "BoundingBox", 1) + `,`,
		`BackgroundColor:` + strings.Replace(this.BackgroundColor.String(), "Color", "Color", 1) + `,`,
		`LeftBorderWidth:` + fmt.Sprintf("%v", this.LeftBorderWidth) + `,`,
		`RightBorderWidth:` + fmt.Sprintf("%v", this.RightBorderWidth) + `,`,
		`TopBorderWidth:` + fmt.Sprintf("%v", this.TopBorderWidth) + `,`,
		`BottomBorderWidth:` + fmt.Sprintf("%v", this.BottomBorderWidth) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Font) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Font{`,
		`CharacterSpan:` + strings.Replace(this.CharacterSpan.String(), "Span", "Span", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Serif:` + fmt.Sprintf("%v", this.Serif) + `,`,
		`Monospace:` + fmt.Sprintf("%v", this.Monospace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FontSize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FontSize{`,
		`CharacterSpan:` + strings.Replace(this.CharacterSpan.String(), "Span", "Span", 1) + `,`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FontStyle) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FontStyle{`,
		`CharacterSpan:` + strings.Replace(this.CharacterSpan.String(), "Span", "Span", 1) + `,`,
		`Style:` + fmt.Sprintf("%v", this.Style) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Color) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Color{`,
		`R:` + fmt.Sprintf("%v", this.R) + `,`,
		`G:` + fmt.Sprintf("%v", this.G) + `,`,
		`B:` + fmt.Sprintf("%v", this.B) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BoundingBox) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoundingBox{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`Y1:` + fmt.Sprintf("%v", this.Y1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`Y2:` + fmt.Sprintf("%v", this.Y2) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Span) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Span{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringRecognitionResults(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Characters = append(m.Characters, &Character{})
			if err := m.Characters[len(m.Characters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &Table{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableCells = append(m.TableCells, &TableCell{})
			if err := m.TableCells[len(m.TableCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fonts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fonts = append(m.Fonts, &Font{})
			if err := m.Fonts[len(m.Fonts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FontSizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FontSizes = append(m.FontSizes, &FontSize{})
			if err := m.FontSizes[len(m.FontSizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FontStyles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FontStyles = append(m.FontStyles, &FontStyle{})
			if err := m.FontStyles[len(m.FontStyles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Character) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Character: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Character: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unicode", wireType)
			}
			m.Unicode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unicode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingBox == nil {
				m.BoundingBox = &BoundingBox{}
			}
			if err := m.BoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CharacterSpan == nil {
				m.CharacterSpan = &Span{}
			}
			if err := m.CharacterSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpiX", wireType)
			}
			m.DpiX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpiX |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpiY", wireType)
			}
			m.DpiY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpiY |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNumber", wireType)
			}
			m.PageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingBox == nil {
				m.BoundingBox = &BoundingBox{}
			}
			if err := m.BoundingBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundColor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackgroundColor == nil {
				m.BackgroundColor = &Color{}
			}
			if err := m.BackgroundColor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftBorderWidth", wireType)
			}
			m.LeftBorderWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftBorderWidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightBorderWidth", wireType)
			}
			m.RightBorderWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightBorderWidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopBorderWidth", wireType)
			}
			m.TopBorderWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopBorderWidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomBorderWidth", wireType)
			}
			m.BottomBorderWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BottomBorderWidth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Font) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Font: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Font: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CharacterSpan == nil {
				m.CharacterSpan = &Span{}
			}
			if err := m.CharacterSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serif", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Serif = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monospace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Monospace = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FontSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FontSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FontSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CharacterSpan == nil {
				m.CharacterSpan = &Span{}
			}
			if err := m.CharacterSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FontStyle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FontStyle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FontStyle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CharacterSpan == nil {
				m.CharacterSpan = &Span{}
			}
			if err := m.CharacterSpan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= FontStyle_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Color) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Color: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Color: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			m.R = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.R |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			m.G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.G |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoundingBox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoundingBox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoundingBox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			m.X1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y1", wireType)
			}
			m.Y1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			m.X2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X2 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y2", wireType)
			}
			m.Y2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y2 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRecognitionResults(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRecognitionResults
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRecognitionResults(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRecognitionResults
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRecognitionResults
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRecognitionResults
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRecognitionResults
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRecognitionResults
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRecognitionResults        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRecognitionResults          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRecognitionResults = fmt.Errorf("proto: unexpected end of group")
)
